{"ast":null,"code":"/*! @azure/msal-common v7.6.0 2022-10-10 */\n'use strict';\n\nimport { __awaiter, __generator, __assign } from '../_virtual/_tslib.js';\nimport { AuthorityType } from './AuthorityType.js';\nimport { isOpenIdConfigResponse } from './OpenIdConfigResponse.js';\nimport { UrlString } from '../url/UrlString.js';\nimport { ClientAuthError } from '../error/ClientAuthError.js';\nimport { Constants, AuthorityMetadataSource, RegionDiscoveryOutcomes } from '../utils/Constants.js';\nimport { EndpointMetadata, InstanceDiscoveryMetadata } from './AuthorityMetadata.js';\nimport { ClientConfigurationError } from '../error/ClientConfigurationError.js';\nimport { ProtocolMode } from './ProtocolMode.js';\nimport { AuthorityMetadataEntity } from '../cache/entities/AuthorityMetadataEntity.js';\nimport { AzureCloudInstance } from './AuthorityOptions.js';\nimport { isCloudInstanceDiscoveryResponse } from './CloudInstanceDiscoveryResponse.js';\nimport { RegionDiscovery } from './RegionDiscovery.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * The authority class validates the authority URIs used by the user, and retrieves the OpenID Configuration Data from the\r\n * endpoint. It will store the pertinent config data in this object for use during token calls.\r\n */\nvar Authority = /** @class */function () {\n  function Authority(authority, networkInterface, cacheManager, authorityOptions, proxyUrl) {\n    this.canonicalAuthority = authority;\n    this._canonicalAuthority.validateAsUri();\n    this.networkInterface = networkInterface;\n    this.cacheManager = cacheManager;\n    this.authorityOptions = authorityOptions;\n    this.regionDiscovery = new RegionDiscovery(networkInterface);\n    this.regionDiscoveryMetadata = {\n      region_used: undefined,\n      region_source: undefined,\n      region_outcome: undefined\n    };\n    this.proxyUrl = proxyUrl || Constants.EMPTY_STRING;\n  }\n  Object.defineProperty(Authority.prototype, \"authorityType\", {\n    // See above for AuthorityType\n    get: function get() {\n      var pathSegments = this.canonicalAuthorityUrlComponents.PathSegments;\n      if (pathSegments.length) {\n        switch (pathSegments[0].toLowerCase()) {\n          case Constants.ADFS:\n            return AuthorityType.Adfs;\n          case Constants.DSTS:\n            return AuthorityType.Dsts;\n        }\n      }\n      return AuthorityType.Default;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"protocolMode\", {\n    /**\r\n     * ProtocolMode enum representing the way endpoints are constructed.\r\n     */\n    get: function get() {\n      return this.authorityOptions.protocolMode;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"options\", {\n    /**\r\n     * Returns authorityOptions which can be used to reinstantiate a new authority instance\r\n     */\n    get: function get() {\n      return this.authorityOptions;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"canonicalAuthority\", {\n    /**\r\n     * A URL that is the authority set by the developer\r\n     */\n    get: function get() {\n      return this._canonicalAuthority.urlString;\n    },\n    /**\r\n     * Sets canonical authority.\r\n     */\n    set: function set(url) {\n      this._canonicalAuthority = new UrlString(url);\n      this._canonicalAuthority.validateAsUri();\n      this._canonicalAuthorityUrlComponents = null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"canonicalAuthorityUrlComponents\", {\n    /**\r\n     * Get authority components.\r\n     */\n    get: function get() {\n      if (!this._canonicalAuthorityUrlComponents) {\n        this._canonicalAuthorityUrlComponents = this._canonicalAuthority.getUrlComponents();\n      }\n      return this._canonicalAuthorityUrlComponents;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"hostnameAndPort\", {\n    /**\r\n     * Get hostname and port i.e. login.microsoftonline.com\r\n     */\n    get: function get() {\n      return this.canonicalAuthorityUrlComponents.HostNameAndPort.toLowerCase();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"tenant\", {\n    /**\r\n     * Get tenant for authority.\r\n     */\n    get: function get() {\n      return this.canonicalAuthorityUrlComponents.PathSegments[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"authorizationEndpoint\", {\n    /**\r\n     * OAuth /authorize endpoint for requests\r\n     */\n    get: function get() {\n      if (this.discoveryComplete()) {\n        var endpoint = this.replacePath(this.metadata.authorization_endpoint);\n        return this.replaceTenant(endpoint);\n      } else {\n        throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"tokenEndpoint\", {\n    /**\r\n     * OAuth /token endpoint for requests\r\n     */\n    get: function get() {\n      if (this.discoveryComplete()) {\n        var endpoint = this.replacePath(this.metadata.token_endpoint);\n        return this.replaceTenant(endpoint);\n      } else {\n        throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"deviceCodeEndpoint\", {\n    get: function get() {\n      if (this.discoveryComplete()) {\n        var endpoint = this.replacePath(this.metadata.token_endpoint.replace(\"/token\", \"/devicecode\"));\n        return this.replaceTenant(endpoint);\n      } else {\n        throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"endSessionEndpoint\", {\n    /**\r\n     * OAuth logout endpoint for requests\r\n     */\n    get: function get() {\n      if (this.discoveryComplete()) {\n        // ROPC policies may not have end_session_endpoint set\n        if (!this.metadata.end_session_endpoint) {\n          throw ClientAuthError.createLogoutNotSupportedError();\n        }\n        var endpoint = this.replacePath(this.metadata.end_session_endpoint);\n        return this.replaceTenant(endpoint);\n      } else {\n        throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"selfSignedJwtAudience\", {\n    /**\r\n     * OAuth issuer for requests\r\n     */\n    get: function get() {\n      if (this.discoveryComplete()) {\n        var endpoint = this.replacePath(this.metadata.issuer);\n        return this.replaceTenant(endpoint);\n      } else {\n        throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"jwksUri\", {\n    /**\r\n     * Jwks_uri for token signing keys\r\n     */\n    get: function get() {\n      if (this.discoveryComplete()) {\n        var endpoint = this.replacePath(this.metadata.jwks_uri);\n        return this.replaceTenant(endpoint);\n      } else {\n        throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Replaces tenant in url path with current tenant. Defaults to common.\r\n   * @param urlString\r\n   */\n  Authority.prototype.replaceTenant = function (urlString) {\n    return urlString.replace(/{tenant}|{tenantid}/g, this.tenant);\n  };\n  /**\r\n   * Replaces path such as tenant or policy with the current tenant or policy.\r\n   * @param urlString\r\n   */\n  Authority.prototype.replacePath = function (urlString) {\n    var endpoint = urlString;\n    var cachedAuthorityUrl = new UrlString(this.metadata.canonical_authority);\n    var cachedAuthorityParts = cachedAuthorityUrl.getUrlComponents().PathSegments;\n    var currentAuthorityParts = this.canonicalAuthorityUrlComponents.PathSegments;\n    currentAuthorityParts.forEach(function (currentPart, index) {\n      var cachedPart = cachedAuthorityParts[index];\n      if (currentPart !== cachedPart) {\n        endpoint = endpoint.replace(\"/\" + cachedPart + \"/\", \"/\" + currentPart + \"/\");\n      }\n    });\n    return endpoint;\n  };\n  Object.defineProperty(Authority.prototype, \"defaultOpenIdConfigurationEndpoint\", {\n    /**\r\n     * The default open id configuration endpoint for any canonical authority.\r\n     */\n    get: function get() {\n      if (this.authorityType === AuthorityType.Adfs || this.authorityType === AuthorityType.Dsts || this.protocolMode === ProtocolMode.OIDC) {\n        return this.canonicalAuthority + \".well-known/openid-configuration\";\n      }\n      return this.canonicalAuthority + \"v2.0/.well-known/openid-configuration\";\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Boolean that returns whethr or not tenant discovery has been completed.\r\n   */\n  Authority.prototype.discoveryComplete = function () {\n    return !!this.metadata;\n  };\n  /**\r\n   * Perform endpoint discovery to discover aliases, preferred_cache, preferred_network\r\n   * and the /authorize, /token and logout endpoints.\r\n   */\n  Authority.prototype.resolveEndpointsAsync = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var metadataEntity, cloudDiscoverySource, endpointSource, cacheKey;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            metadataEntity = this.cacheManager.getAuthorityMetadataByAlias(this.hostnameAndPort);\n            if (!metadataEntity) {\n              metadataEntity = new AuthorityMetadataEntity();\n              metadataEntity.updateCanonicalAuthority(this.canonicalAuthority);\n            }\n            return [4 /*yield*/, this.updateCloudDiscoveryMetadata(metadataEntity)];\n          case 1:\n            cloudDiscoverySource = _a.sent();\n            this.canonicalAuthority = this.canonicalAuthority.replace(this.hostnameAndPort, metadataEntity.preferred_network);\n            return [4 /*yield*/, this.updateEndpointMetadata(metadataEntity)];\n          case 2:\n            endpointSource = _a.sent();\n            if (cloudDiscoverySource !== AuthorityMetadataSource.CACHE && endpointSource !== AuthorityMetadataSource.CACHE) {\n              // Reset the expiration time unless both values came from a successful cache lookup\n              metadataEntity.resetExpiresAt();\n              metadataEntity.updateCanonicalAuthority(this.canonicalAuthority);\n            }\n            cacheKey = this.cacheManager.generateAuthorityMetadataCacheKey(metadataEntity.preferred_cache);\n            this.cacheManager.setAuthorityMetadata(cacheKey, metadataEntity);\n            this.metadata = metadataEntity;\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\r\n   * Update AuthorityMetadataEntity with new endpoints and return where the information came from\r\n   * @param metadataEntity\r\n   */\n  Authority.prototype.updateEndpointMetadata = function (metadataEntity) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function () {\n      var metadata, harcodedMetadata;\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            metadata = this.getEndpointMetadataFromConfig();\n            if (metadata) {\n              metadataEntity.updateEndpointMetadata(metadata, false);\n              return [2 /*return*/, AuthorityMetadataSource.CONFIG];\n            }\n            if (this.isAuthoritySameType(metadataEntity) && metadataEntity.endpointsFromNetwork && !metadataEntity.isExpired()) {\n              // No need to update\n              return [2 /*return*/, AuthorityMetadataSource.CACHE];\n            }\n            harcodedMetadata = this.getEndpointMetadataFromHardcodedValues();\n            return [4 /*yield*/, this.getEndpointMetadataFromNetwork()];\n          case 1:\n            metadata = _c.sent();\n            if (!metadata) return [3 /*break*/, 4];\n            if (!((_a = this.authorityOptions.azureRegionConfiguration) === null || _a === void 0 ? void 0 : _a.azureRegion)) return [3 /*break*/, 3];\n            return [4 /*yield*/, this.updateMetadataWithRegionalInformation(metadata)];\n          case 2:\n            metadata = _c.sent();\n            _c.label = 3;\n          case 3:\n            metadataEntity.updateEndpointMetadata(metadata, true);\n            return [2 /*return*/, AuthorityMetadataSource.NETWORK];\n          case 4:\n            if (!(harcodedMetadata && !this.authorityOptions.skipAuthorityMetadataCache)) return [3 /*break*/, 7];\n            if (!((_b = this.authorityOptions.azureRegionConfiguration) === null || _b === void 0 ? void 0 : _b.azureRegion)) return [3 /*break*/, 6];\n            return [4 /*yield*/, this.updateMetadataWithRegionalInformation(harcodedMetadata)];\n          case 5:\n            harcodedMetadata = _c.sent();\n            _c.label = 6;\n          case 6:\n            metadataEntity.updateEndpointMetadata(harcodedMetadata, false);\n            return [2 /*return*/, AuthorityMetadataSource.HARDCODED_VALUES];\n          case 7:\n            throw ClientAuthError.createUnableToGetOpenidConfigError(this.defaultOpenIdConfigurationEndpoint);\n        }\n      });\n    });\n  };\n  /**\r\n   * Compares the number of url components after the domain to determine if the cached\r\n   * authority metadata can be used for the requested authority. Protects against same domain different\r\n   * authority such as login.microsoftonline.com/tenant and login.microsoftonline.com/tfp/tenant/policy\r\n   * @param metadataEntity\r\n   */\n  Authority.prototype.isAuthoritySameType = function (metadataEntity) {\n    var cachedAuthorityUrl = new UrlString(metadataEntity.canonical_authority);\n    var cachedParts = cachedAuthorityUrl.getUrlComponents().PathSegments;\n    return cachedParts.length === this.canonicalAuthorityUrlComponents.PathSegments.length;\n  };\n  /**\r\n   * Parse authorityMetadata config option\r\n   */\n  Authority.prototype.getEndpointMetadataFromConfig = function () {\n    if (this.authorityOptions.authorityMetadata) {\n      try {\n        return JSON.parse(this.authorityOptions.authorityMetadata);\n      } catch (e) {\n        throw ClientConfigurationError.createInvalidAuthorityMetadataError();\n      }\n    }\n    return null;\n  };\n  /**\r\n   * Gets OAuth endpoints from the given OpenID configuration endpoint.\r\n   *\r\n   * @param hasHardcodedMetadata boolean\r\n   */\n  Authority.prototype.getEndpointMetadataFromNetwork = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var options, response;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            options = {};\n            if (this.proxyUrl) {\n              options.proxyUrl = this.proxyUrl;\n            }\n            _a.label = 1;\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n            return [4 /*yield*/, this.networkInterface.sendGetRequestAsync(this.defaultOpenIdConfigurationEndpoint, options)];\n          case 2:\n            response = _a.sent();\n            return [2 /*return*/, isOpenIdConfigResponse(response.body) ? response.body : null];\n          case 3:\n            _a.sent();\n            return [2 /*return*/, null];\n          case 4:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\r\n   * Get OAuth endpoints for common authorities.\r\n   */\n  Authority.prototype.getEndpointMetadataFromHardcodedValues = function () {\n    if (this.canonicalAuthority in EndpointMetadata) {\n      return EndpointMetadata[this.canonicalAuthority];\n    }\n    return null;\n  };\n  /**\r\n   * Update the retrieved metadata with regional information.\r\n   */\n  Authority.prototype.updateMetadataWithRegionalInformation = function (metadata) {\n    var _a, _b, _c, _d, _e;\n    return __awaiter(this, void 0, void 0, function () {\n      var autodetectedRegionName, azureRegion;\n      return __generator(this, function (_f) {\n        switch (_f.label) {\n          case 0:\n            return [4 /*yield*/, this.regionDiscovery.detectRegion((_a = this.authorityOptions.azureRegionConfiguration) === null || _a === void 0 ? void 0 : _a.environmentRegion, this.regionDiscoveryMetadata, this.proxyUrl)];\n          case 1:\n            autodetectedRegionName = _f.sent();\n            azureRegion = ((_b = this.authorityOptions.azureRegionConfiguration) === null || _b === void 0 ? void 0 : _b.azureRegion) === Constants.AZURE_REGION_AUTO_DISCOVER_FLAG ? autodetectedRegionName : (_c = this.authorityOptions.azureRegionConfiguration) === null || _c === void 0 ? void 0 : _c.azureRegion;\n            if (((_d = this.authorityOptions.azureRegionConfiguration) === null || _d === void 0 ? void 0 : _d.azureRegion) === Constants.AZURE_REGION_AUTO_DISCOVER_FLAG) {\n              this.regionDiscoveryMetadata.region_outcome = autodetectedRegionName ? RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_SUCCESSFUL : RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_FAILED;\n            } else {\n              if (autodetectedRegionName) {\n                this.regionDiscoveryMetadata.region_outcome = ((_e = this.authorityOptions.azureRegionConfiguration) === null || _e === void 0 ? void 0 : _e.azureRegion) === autodetectedRegionName ? RegionDiscoveryOutcomes.CONFIGURED_MATCHES_DETECTED : RegionDiscoveryOutcomes.CONFIGURED_NOT_DETECTED;\n              } else {\n                this.regionDiscoveryMetadata.region_outcome = RegionDiscoveryOutcomes.CONFIGURED_NO_AUTO_DETECTION;\n              }\n            }\n            if (azureRegion) {\n              this.regionDiscoveryMetadata.region_used = azureRegion;\n              return [2 /*return*/, Authority.replaceWithRegionalInformation(metadata, azureRegion)];\n            }\n            return [2 /*return*/, metadata];\n        }\n      });\n    });\n  };\n  /**\r\n   * Updates the AuthorityMetadataEntity with new aliases, preferred_network and preferred_cache\r\n   * and returns where the information was retrieved from\r\n   * @param cachedMetadata\r\n   * @param newMetadata\r\n   */\n  Authority.prototype.updateCloudDiscoveryMetadata = function (metadataEntity) {\n    return __awaiter(this, void 0, void 0, function () {\n      var metadata, harcodedMetadata;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            metadata = this.getCloudDiscoveryMetadataFromConfig();\n            if (metadata) {\n              metadataEntity.updateCloudDiscoveryMetadata(metadata, false);\n              return [2 /*return*/, AuthorityMetadataSource.CONFIG];\n            }\n            // If The cached metadata came from config but that config was not passed to this instance, we must go to the network\n            if (this.isAuthoritySameType(metadataEntity) && metadataEntity.aliasesFromNetwork && !metadataEntity.isExpired()) {\n              // No need to update\n              return [2 /*return*/, AuthorityMetadataSource.CACHE];\n            }\n            harcodedMetadata = this.getCloudDiscoveryMetadataFromHarcodedValues();\n            return [4 /*yield*/, this.getCloudDiscoveryMetadataFromNetwork()];\n          case 1:\n            metadata = _a.sent();\n            if (metadata) {\n              metadataEntity.updateCloudDiscoveryMetadata(metadata, true);\n              return [2 /*return*/, AuthorityMetadataSource.NETWORK];\n            }\n            if (harcodedMetadata && !this.options.skipAuthorityMetadataCache) {\n              metadataEntity.updateCloudDiscoveryMetadata(harcodedMetadata, false);\n              return [2 /*return*/, AuthorityMetadataSource.HARDCODED_VALUES];\n            } else {\n              // Metadata could not be obtained from config, cache or network\n              throw ClientConfigurationError.createUntrustedAuthorityError();\n            }\n        }\n      });\n    });\n  };\n  /**\r\n   * Parse cloudDiscoveryMetadata config or check knownAuthorities\r\n   */\n  Authority.prototype.getCloudDiscoveryMetadataFromConfig = function () {\n    // Check if network response was provided in config\n    if (this.authorityOptions.cloudDiscoveryMetadata) {\n      try {\n        var parsedResponse = JSON.parse(this.authorityOptions.cloudDiscoveryMetadata);\n        var metadata = Authority.getCloudDiscoveryMetadataFromNetworkResponse(parsedResponse.metadata, this.hostnameAndPort);\n        if (metadata) {\n          return metadata;\n        }\n      } catch (e) {\n        throw ClientConfigurationError.createInvalidCloudDiscoveryMetadataError();\n      }\n    }\n    // If cloudDiscoveryMetadata is empty or does not contain the host, check knownAuthorities\n    if (this.isInKnownAuthorities()) {\n      return Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);\n    }\n    return null;\n  };\n  /**\r\n   * Called to get metadata from network if CloudDiscoveryMetadata was not populated by config\r\n   *\r\n   * @param hasHardcodedMetadata boolean\r\n   */\n  Authority.prototype.getCloudDiscoveryMetadataFromNetwork = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var instanceDiscoveryEndpoint, options, match, response, metadata;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            instanceDiscoveryEndpoint = \"\" + Constants.AAD_INSTANCE_DISCOVERY_ENDPT + this.canonicalAuthority + \"oauth2/v2.0/authorize\";\n            options = {};\n            if (this.proxyUrl) {\n              options.proxyUrl = this.proxyUrl;\n            }\n            match = null;\n            _a.label = 1;\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n            return [4 /*yield*/, this.networkInterface.sendGetRequestAsync(instanceDiscoveryEndpoint, options)];\n          case 2:\n            response = _a.sent();\n            metadata = isCloudInstanceDiscoveryResponse(response.body) ? response.body.metadata : [];\n            if (metadata.length === 0) {\n              // If no metadata is returned, authority is untrusted\n              return [2 /*return*/, null];\n            }\n            match = Authority.getCloudDiscoveryMetadataFromNetworkResponse(metadata, this.hostnameAndPort);\n            return [3 /*break*/, 4];\n          case 3:\n            _a.sent();\n            return [2 /*return*/, null];\n          case 4:\n            if (!match) {\n              // Custom Domain scenario, host is trusted because Instance Discovery call succeeded\n              match = Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);\n            }\n            return [2 /*return*/, match];\n        }\n      });\n    });\n  };\n  /**\r\n   * Get cloud discovery metadata for common authorities\r\n   */\n  Authority.prototype.getCloudDiscoveryMetadataFromHarcodedValues = function () {\n    if (this.canonicalAuthority in InstanceDiscoveryMetadata) {\n      return InstanceDiscoveryMetadata[this.canonicalAuthority];\n    }\n    return null;\n  };\n  /**\r\n   * Helper function to determine if this host is included in the knownAuthorities config option\r\n   */\n  Authority.prototype.isInKnownAuthorities = function () {\n    var _this = this;\n    var matches = this.authorityOptions.knownAuthorities.filter(function (authority) {\n      return UrlString.getDomainFromUrl(authority).toLowerCase() === _this.hostnameAndPort;\n    });\n    return matches.length > 0;\n  };\n  /**\r\n   * helper function to populate the authority based on azureCloudOptions\r\n   * @param authorityString\r\n   * @param azureCloudOptions\r\n   */\n  Authority.generateAuthority = function (authorityString, azureCloudOptions) {\n    var authorityAzureCloudInstance;\n    if (azureCloudOptions && azureCloudOptions.azureCloudInstance !== AzureCloudInstance.None) {\n      var tenant = azureCloudOptions.tenant ? azureCloudOptions.tenant : Constants.DEFAULT_COMMON_TENANT;\n      authorityAzureCloudInstance = azureCloudOptions.azureCloudInstance + \"/\" + tenant + \"/\";\n    }\n    return authorityAzureCloudInstance ? authorityAzureCloudInstance : authorityString;\n  };\n  /**\r\n   * Creates cloud discovery metadata object from a given host\r\n   * @param host\r\n   */\n  Authority.createCloudDiscoveryMetadataFromHost = function (host) {\n    return {\n      preferred_network: host,\n      preferred_cache: host,\n      aliases: [host]\n    };\n  };\n  /**\r\n   * Searches instance discovery network response for the entry that contains the host in the aliases list\r\n   * @param response\r\n   * @param authority\r\n   */\n  Authority.getCloudDiscoveryMetadataFromNetworkResponse = function (response, authority) {\n    for (var i = 0; i < response.length; i++) {\n      var metadata = response[i];\n      if (metadata.aliases.indexOf(authority) > -1) {\n        return metadata;\n      }\n    }\n    return null;\n  };\n  /**\r\n   * helper function to generate environment from authority object\r\n   */\n  Authority.prototype.getPreferredCache = function () {\n    if (this.discoveryComplete()) {\n      return this.metadata.preferred_cache;\n    } else {\n      throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n    }\n  };\n  /**\r\n   * Returns whether or not the provided host is an alias of this authority instance\r\n   * @param host\r\n   */\n  Authority.prototype.isAlias = function (host) {\n    return this.metadata.aliases.indexOf(host) > -1;\n  };\n  /**\r\n   * Checks whether the provided host is that of a public cloud authority\r\n   *\r\n   * @param authority string\r\n   * @returns bool\r\n   */\n  Authority.isPublicCloudAuthority = function (host) {\n    return Constants.KNOWN_PUBLIC_CLOUDS.indexOf(host) >= 0;\n  };\n  /**\r\n   * Rebuild the authority string with the region\r\n   *\r\n   * @param host string\r\n   * @param region string\r\n   */\n  Authority.buildRegionalAuthorityString = function (host, region, queryString) {\n    // Create and validate a Url string object with the initial authority string\n    var authorityUrlInstance = new UrlString(host);\n    authorityUrlInstance.validateAsUri();\n    var authorityUrlParts = authorityUrlInstance.getUrlComponents();\n    var hostNameAndPort = region + \".\" + authorityUrlParts.HostNameAndPort;\n    if (this.isPublicCloudAuthority(authorityUrlParts.HostNameAndPort)) {\n      hostNameAndPort = region + \".\" + Constants.REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX;\n    }\n    // Include the query string portion of the url\n    var url = UrlString.constructAuthorityUriFromObject(__assign(__assign({}, authorityUrlInstance.getUrlComponents()), {\n      HostNameAndPort: hostNameAndPort\n    })).urlString;\n    // Add the query string if a query string was provided\n    if (queryString) return url + \"?\" + queryString;\n    return url;\n  };\n  /**\r\n   * Replace the endpoints in the metadata object with their regional equivalents.\r\n   *\r\n   * @param metadata OpenIdConfigResponse\r\n   * @param azureRegion string\r\n   */\n  Authority.replaceWithRegionalInformation = function (metadata, azureRegion) {\n    metadata.authorization_endpoint = Authority.buildRegionalAuthorityString(metadata.authorization_endpoint, azureRegion);\n    // TODO: Enquire on whether we should leave the query string or remove it before releasing the feature\n    metadata.token_endpoint = Authority.buildRegionalAuthorityString(metadata.token_endpoint, azureRegion, Constants.REGIONAL_AUTH_NON_MSI_QUERY_STRING);\n    if (metadata.end_session_endpoint) {\n      metadata.end_session_endpoint = Authority.buildRegionalAuthorityString(metadata.end_session_endpoint, azureRegion);\n    }\n    return metadata;\n  };\n  return Authority;\n}();\nexport { Authority };","map":null,"metadata":{},"sourceType":"module"}