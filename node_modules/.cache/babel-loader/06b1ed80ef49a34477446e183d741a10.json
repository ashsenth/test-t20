{"ast":null,"code":"/*! @azure/msal-browser v2.30.0 2022-10-10 */\n'use strict';\n\nimport { __extends, __awaiter, __generator, __rest, __assign } from '../_virtual/_tslib.js';\nimport { PerformanceEvents, TimeUtils, ScopeSet, ClientAuthError, IdTokenEntity, Constants, AccessTokenEntity, AuthenticationScheme, PopTokenGenerator, AccountEntity, AuthorityType, AuthToken, UrlString, OIDC_DEFAULT_SCOPES, PromptValue } from '@azure/msal-common';\nimport { BaseInteractionClient } from './BaseInteractionClient.js';\nimport { TemporaryCacheKeys, NativeExtensionMethod, NativeConstants, ApiId } from '../utils/BrowserConstants.js';\nimport { NativeAuthError } from '../error/NativeAuthError.js';\nimport { BrowserAuthError } from '../error/BrowserAuthError.js';\nimport { SilentCacheClient } from './SilentCacheClient.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nvar NativeInteractionClient = /** @class */function (_super) {\n  __extends(NativeInteractionClient, _super);\n  function NativeInteractionClient(config, browserStorage, browserCrypto, logger, eventHandler, navigationClient, apiId, performanceClient, provider, accountId, nativeStorageImpl, correlationId) {\n    var _this = _super.call(this, config, browserStorage, browserCrypto, logger, eventHandler, navigationClient, performanceClient, provider, correlationId) || this;\n    _this.apiId = apiId;\n    _this.accountId = accountId;\n    _this.nativeMessageHandler = provider;\n    _this.nativeStorageManager = nativeStorageImpl;\n    _this.silentCacheClient = new SilentCacheClient(config, _this.nativeStorageManager, browserCrypto, logger, eventHandler, navigationClient, performanceClient, provider, correlationId);\n    return _this;\n  }\n  /**\r\n   * Acquire token from native platform via browser extension\r\n   * @param request\r\n   */\n  NativeInteractionClient.prototype.acquireToken = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var nativeATMeasurement, reqTimestamp, nativeRequest, result, messageBody, response, validatedResponse;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.logger.trace(\"NativeInteractionClient - acquireToken called.\");\n            nativeATMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.NativeInteractionClientAcquireToken, request.correlationId);\n            reqTimestamp = TimeUtils.nowSeconds();\n            return [4 /*yield*/, this.initializeNativeRequest(request)];\n          case 1:\n            nativeRequest = _a.sent();\n            _a.label = 2;\n          case 2:\n            _a.trys.push([2, 4,, 5]);\n            return [4 /*yield*/, this.acquireTokensFromCache(this.accountId, nativeRequest)];\n          case 3:\n            result = _a.sent();\n            nativeATMeasurement.endMeasurement({\n              success: true,\n              isNativeBroker: true,\n              fromCache: true\n            });\n            return [2 /*return*/, result];\n          case 4:\n            _a.sent();\n            // continue with a native call for any and all errors\n            this.logger.info(\"MSAL internal Cache does not contain tokens, proceed to make a native call\");\n            return [3 /*break*/, 5];\n          case 5:\n            messageBody = {\n              method: NativeExtensionMethod.GetToken,\n              request: nativeRequest\n            };\n            return [4 /*yield*/, this.nativeMessageHandler.sendMessage(messageBody)];\n          case 6:\n            response = _a.sent();\n            validatedResponse = this.validateNativeResponse(response);\n            return [2 /*return*/, this.handleNativeResponse(validatedResponse, nativeRequest, reqTimestamp).then(function (result) {\n              nativeATMeasurement.endMeasurement({\n                success: true,\n                isNativeBroker: true,\n                requestId: result.requestId\n              });\n              return result;\n            }).catch(function (error) {\n              nativeATMeasurement.endMeasurement({\n                success: false,\n                errorCode: error.errorCode,\n                subErrorCode: error.subError,\n                isNativeBroker: true\n              });\n              throw error;\n            })];\n        }\n      });\n    });\n  };\n  /**\r\n   * Creates silent flow request\r\n   * @param request\r\n   * @param cachedAccount\r\n   * @returns CommonSilentFlowRequest\r\n   */\n  NativeInteractionClient.prototype.createSilentCacheRequest = function (request, cachedAccount) {\n    return {\n      authority: request.authority,\n      correlationId: this.correlationId,\n      scopes: ScopeSet.fromString(request.scope).asArray(),\n      account: cachedAccount,\n      forceRefresh: false\n    };\n  };\n  /**\r\n   * Fetches the tokens from the cache if un-expired\r\n   * @param nativeAccountId\r\n   * @param request\r\n   * @returns authenticationResult\r\n   */\n  NativeInteractionClient.prototype.acquireTokensFromCache = function (nativeAccountId, request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var accountEntity, account, silentRequest, result, e_2;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            accountEntity = this.browserStorage.readAccountFromCacheWithNativeAccountId(nativeAccountId);\n            if (!accountEntity) {\n              throw ClientAuthError.createNoAccountFoundError();\n            }\n            account = accountEntity.getAccountInfo();\n            _a.label = 1;\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n            silentRequest = this.createSilentCacheRequest(request, account);\n            return [4 /*yield*/, this.silentCacheClient.acquireToken(silentRequest)];\n          case 2:\n            result = _a.sent();\n            return [2 /*return*/, result];\n          case 3:\n            e_2 = _a.sent();\n            throw e_2;\n          case 4:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\r\n   * Acquires a token from native platform then redirects to the redirectUri instead of returning the response\r\n   * @param request\r\n   */\n  NativeInteractionClient.prototype.acquireTokenRedirect = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var nativeRequest, messageBody, response, e_3, navigationOptions, redirectUri;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.logger.trace(\"NativeInteractionClient - acquireTokenRedirect called.\");\n            return [4 /*yield*/, this.initializeNativeRequest(request)];\n          case 1:\n            nativeRequest = _a.sent();\n            messageBody = {\n              method: NativeExtensionMethod.GetToken,\n              request: nativeRequest\n            };\n            _a.label = 2;\n          case 2:\n            _a.trys.push([2, 4,, 5]);\n            return [4 /*yield*/, this.nativeMessageHandler.sendMessage(messageBody)];\n          case 3:\n            response = _a.sent();\n            this.validateNativeResponse(response);\n            return [3 /*break*/, 5];\n          case 4:\n            e_3 = _a.sent();\n            // Only throw fatal errors here to allow application to fallback to regular redirect. Otherwise proceed and the error will be thrown in handleRedirectPromise\n            if (e_3 instanceof NativeAuthError && e_3.isFatal()) {\n              throw e_3;\n            }\n            return [3 /*break*/, 5];\n          case 5:\n            this.browserStorage.setTemporaryCache(TemporaryCacheKeys.NATIVE_REQUEST, JSON.stringify(nativeRequest), true);\n            navigationOptions = {\n              apiId: ApiId.acquireTokenRedirect,\n              timeout: this.config.system.redirectNavigationTimeout,\n              noHistory: false\n            };\n            redirectUri = this.config.auth.navigateToLoginRequestUrl ? window.location.href : this.getRedirectUri(request.redirectUri);\n            return [4 /*yield*/, this.navigationClient.navigateExternal(redirectUri, navigationOptions)];\n          case 6:\n            _a.sent(); // Need to treat this as external to ensure handleRedirectPromise is run again\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\r\n   * If the previous page called native platform for a token using redirect APIs, send the same request again and return the response\r\n   */\n  NativeInteractionClient.prototype.handleRedirectPromise = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var cachedRequest, messageBody, reqTimestamp, response, result, e_4;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.logger.trace(\"NativeInteractionClient - handleRedirectPromise called.\");\n            if (!this.browserStorage.isInteractionInProgress(true)) {\n              this.logger.info(\"handleRedirectPromise called but there is no interaction in progress, returning null.\");\n              return [2 /*return*/, null];\n            }\n            cachedRequest = this.browserStorage.getCachedNativeRequest();\n            if (!cachedRequest) {\n              this.logger.verbose(\"NativeInteractionClient - handleRedirectPromise called but there is no cached request, returning null.\");\n              return [2 /*return*/, null];\n            }\n            this.browserStorage.removeItem(this.browserStorage.generateCacheKey(TemporaryCacheKeys.NATIVE_REQUEST));\n            messageBody = {\n              method: NativeExtensionMethod.GetToken,\n              request: cachedRequest\n            };\n            reqTimestamp = TimeUtils.nowSeconds();\n            _a.label = 1;\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n            this.logger.verbose(\"NativeInteractionClient - handleRedirectPromise sending message to native broker.\");\n            return [4 /*yield*/, this.nativeMessageHandler.sendMessage(messageBody)];\n          case 2:\n            response = _a.sent();\n            this.validateNativeResponse(response);\n            result = this.handleNativeResponse(response, cachedRequest, reqTimestamp);\n            this.browserStorage.setInteractionInProgress(false);\n            return [2 /*return*/, result];\n          case 3:\n            e_4 = _a.sent();\n            this.browserStorage.setInteractionInProgress(false);\n            throw e_4;\n          case 4:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\r\n   * Logout from native platform via browser extension\r\n   * @param request\r\n   */\n  NativeInteractionClient.prototype.logout = function () {\n    this.logger.trace(\"NativeInteractionClient - logout called.\");\n    return Promise.reject(\"Logout not implemented yet\");\n  };\n  /**\r\n   * Transform response from native platform into AuthenticationResult object which will be returned to the end user\r\n   * @param response\r\n   * @param request\r\n   * @param reqTimestamp\r\n   */\n  NativeInteractionClient.prototype.handleNativeResponse = function (response, request, reqTimestamp) {\n    return __awaiter(this, void 0, void 0, function () {\n      var idTokenObj, authority, authorityPreferredCache, homeAccountIdentifier, accountEntity, responseScopes, accountProperties, uid, tid, responseAccessToken, responseTokenType, _a, popTokenGenerator, shrParameters, mats, result, idTokenEntity, expiresIn, tokenExpirationSeconds, accessTokenEntity;\n      var _this = this;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            this.logger.trace(\"NativeInteractionClient - handleNativeResponse called.\");\n            if (response.account.id !== request.accountId) {\n              // User switch in native broker prompt is not supported. All users must first sign in through web flow to ensure server state is in sync\n              throw NativeAuthError.createUserSwitchError();\n            }\n            idTokenObj = new AuthToken(response.id_token || Constants.EMPTY_STRING, this.browserCrypto);\n            return [4 /*yield*/, this.getDiscoveredAuthority(request.authority)];\n          case 1:\n            authority = _b.sent();\n            authorityPreferredCache = authority.getPreferredCache();\n            homeAccountIdentifier = AccountEntity.generateHomeAccountId(response.client_info || Constants.EMPTY_STRING, AuthorityType.Default, this.logger, this.browserCrypto, idTokenObj);\n            accountEntity = AccountEntity.createAccount(response.client_info, homeAccountIdentifier, idTokenObj, undefined, undefined, undefined, authorityPreferredCache, response.account.id);\n            this.browserStorage.setAccount(accountEntity);\n            responseScopes = response.scope ? ScopeSet.fromString(response.scope) : ScopeSet.fromString(request.scope);\n            accountProperties = response.account.properties || {};\n            uid = accountProperties[\"UID\"] || idTokenObj.claims.oid || idTokenObj.claims.sub || Constants.EMPTY_STRING;\n            tid = accountProperties[\"TenantId\"] || idTokenObj.claims.tid || Constants.EMPTY_STRING;\n            responseTokenType = AuthenticationScheme.BEARER;\n            _a = request.tokenType;\n            switch (_a) {\n              case AuthenticationScheme.POP:\n                return [3 /*break*/, 2];\n            }\n            return [3 /*break*/, 4];\n          case 2:\n            // Set the token type to POP in the response\n            responseTokenType = AuthenticationScheme.POP;\n            // Check if native layer returned an SHR token\n            if (response.shr) {\n              this.logger.trace(\"handleNativeServerResponse: SHR is enabled in native layer\");\n              responseAccessToken = response.shr;\n              return [3 /*break*/, 5];\n            }\n            popTokenGenerator = new PopTokenGenerator(this.browserCrypto);\n            shrParameters = {\n              resourceRequestMethod: request.resourceRequestMethod,\n              resourceRequestUri: request.resourceRequestUri,\n              shrClaims: request.shrClaims,\n              shrNonce: request.shrNonce\n            };\n            /**\r\n             * KeyID must be present in the native request from when the PoP key was generated in order for\r\n             * PopTokenGenerator to query the full key for signing\r\n             */\n            if (!request.keyId) {\n              throw ClientAuthError.createKeyIdMissingError();\n            }\n            return [4 /*yield*/, popTokenGenerator.signPopToken(response.access_token, request.keyId, shrParameters)];\n          case 3:\n            responseAccessToken = _b.sent();\n            return [3 /*break*/, 5];\n          case 4:\n            {\n              responseAccessToken = response.access_token;\n            }\n            _b.label = 5;\n          case 5:\n            mats = this.getMATSFromResponse(response);\n            result = {\n              authority: authority.canonicalAuthority,\n              uniqueId: uid,\n              tenantId: tid,\n              scopes: responseScopes.asArray(),\n              account: accountEntity.getAccountInfo(),\n              idToken: response.id_token,\n              idTokenClaims: idTokenObj.claims,\n              accessToken: responseAccessToken,\n              fromCache: mats ? this.isResponseFromCache(mats) : false,\n              expiresOn: new Date(Number(reqTimestamp + response.expires_in) * 1000),\n              tokenType: responseTokenType,\n              correlationId: this.correlationId,\n              state: response.state,\n              fromNativeBroker: true\n            };\n            idTokenEntity = IdTokenEntity.createIdTokenEntity(homeAccountIdentifier, request.authority, response.id_token || Constants.EMPTY_STRING, request.clientId, idTokenObj.claims.tid || Constants.EMPTY_STRING);\n            this.nativeStorageManager.setIdTokenCredential(idTokenEntity);\n            expiresIn = responseTokenType === AuthenticationScheme.POP ? Constants.SHR_NONCE_VALIDITY : (typeof response.expires_in === \"string\" ? parseInt(response.expires_in, 10) : response.expires_in) || 0;\n            tokenExpirationSeconds = reqTimestamp + expiresIn;\n            accessTokenEntity = AccessTokenEntity.createAccessTokenEntity(homeAccountIdentifier, request.authority, responseAccessToken, request.clientId, tid, responseScopes.printScopes(), tokenExpirationSeconds, 0, this.browserCrypto);\n            this.nativeStorageManager.setAccessTokenCredential(accessTokenEntity);\n            // Remove any existing cached tokens for this account in browser storage\n            this.browserStorage.removeAccountContext(accountEntity).catch(function (e) {\n              _this.logger.error(\"Error occurred while removing account context from browser storage. \" + e);\n            });\n            return [2 /*return*/, result];\n        }\n      });\n    });\n  };\n  /**\r\n   * Validates native platform response before processing\r\n   * @param response\r\n   */\n  NativeInteractionClient.prototype.validateNativeResponse = function (response) {\n    if (response.hasOwnProperty(\"access_token\") && response.hasOwnProperty(\"id_token\") && response.hasOwnProperty(\"client_info\") && response.hasOwnProperty(\"account\") && response.hasOwnProperty(\"scope\") && response.hasOwnProperty(\"expires_in\")) {\n      return response;\n    } else {\n      throw NativeAuthError.createUnexpectedError(\"Response missing expected properties.\");\n    }\n  };\n  /**\r\n   * Gets MATS telemetry from native response\r\n   * @param response\r\n   * @returns\r\n   */\n  NativeInteractionClient.prototype.getMATSFromResponse = function (response) {\n    if (response.properties.MATS) {\n      try {\n        return JSON.parse(response.properties.MATS);\n      } catch (e) {\n        this.logger.error(\"NativeInteractionClient - Error parsing MATS telemetry, returning null instead\");\n      }\n    }\n    return null;\n  };\n  /**\r\n   * Returns whether or not response came from native cache\r\n   * @param response\r\n   * @returns\r\n   */\n  NativeInteractionClient.prototype.isResponseFromCache = function (mats) {\n    if (typeof mats.is_cached === \"undefined\") {\n      this.logger.verbose(\"NativeInteractionClient - MATS telemetry does not contain field indicating if response was served from cache. Returning false.\");\n      return false;\n    }\n    return !!mats.is_cached;\n  };\n  /**\r\n   * Translates developer provided request object into NativeRequest object\r\n   * @param request\r\n   */\n  NativeInteractionClient.prototype.initializeNativeRequest = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var authority, canonicalAuthority, scopes, remainingProperties, scopeSet, getPrompt, validatedRequest, shrParameters, popTokenGenerator, reqCnfData;\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.logger.trace(\"NativeInteractionClient - initializeNativeRequest called\");\n            authority = request.authority || this.config.auth.authority;\n            canonicalAuthority = new UrlString(authority);\n            canonicalAuthority.validateAsUri();\n            scopes = request.scopes, remainingProperties = __rest(request, [\"scopes\"]);\n            scopeSet = new ScopeSet(scopes || []);\n            scopeSet.appendScopes(OIDC_DEFAULT_SCOPES);\n            getPrompt = function getPrompt() {\n              // If request is silent, prompt is always none\n              switch (_this.apiId) {\n                case ApiId.ssoSilent:\n                case ApiId.acquireTokenSilent_silentFlow:\n                  _this.logger.trace(\"initializeNativeRequest: silent request sets prompt to none\");\n                  return PromptValue.NONE;\n              }\n              // Prompt not provided, request may proceed and native broker decides if it needs to prompt\n              if (!request.prompt) {\n                _this.logger.trace(\"initializeNativeRequest: prompt was not provided\");\n                return undefined;\n              }\n              // If request is interactive, check if prompt provided is allowed to go directly to native broker\n              switch (request.prompt) {\n                case PromptValue.NONE:\n                case PromptValue.CONSENT:\n                case PromptValue.LOGIN:\n                  _this.logger.trace(\"initializeNativeRequest: prompt is compatible with native flow\");\n                  return request.prompt;\n                default:\n                  _this.logger.trace(\"initializeNativeRequest: prompt = \" + request.prompt + \" is not compatible with native flow\");\n                  throw BrowserAuthError.createNativePromptParameterNotSupportedError();\n              }\n            };\n            validatedRequest = __assign(__assign({}, remainingProperties), {\n              accountId: this.accountId,\n              clientId: this.config.auth.clientId,\n              authority: canonicalAuthority.urlString,\n              scope: scopeSet.printScopes(),\n              redirectUri: this.getRedirectUri(request.redirectUri),\n              prompt: getPrompt(),\n              correlationId: this.correlationId,\n              tokenType: request.authenticationScheme,\n              windowTitleSubstring: document.title,\n              extraParameters: __assign(__assign(__assign({}, request.extraQueryParameters), request.tokenQueryParameters), {\n                telemetry: NativeConstants.MATS_TELEMETRY\n              }),\n              extendedExpiryToken: false // Make this configurable?\n            });\n\n            if (!(request.authenticationScheme === AuthenticationScheme.POP)) return [3 /*break*/, 2];\n            shrParameters = {\n              resourceRequestUri: request.resourceRequestUri,\n              resourceRequestMethod: request.resourceRequestMethod,\n              shrClaims: request.shrClaims,\n              shrNonce: request.shrNonce\n            };\n            popTokenGenerator = new PopTokenGenerator(this.browserCrypto);\n            return [4 /*yield*/, popTokenGenerator.generateCnf(shrParameters)];\n          case 1:\n            reqCnfData = _a.sent();\n            // to reduce the URL length, it is recommended to send the hash of the req_cnf instead of the whole string\n            validatedRequest.reqCnf = reqCnfData.reqCnfHash;\n            validatedRequest.keyId = reqCnfData.kid;\n            _a.label = 2;\n          case 2:\n            return [2 /*return*/, validatedRequest];\n        }\n      });\n    });\n  };\n  return NativeInteractionClient;\n}(BaseInteractionClient);\nexport { NativeInteractionClient };","map":null,"metadata":{},"sourceType":"module"}